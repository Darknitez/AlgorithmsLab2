import java.util.*;


//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {

	private int rec;
	private int m;
	private Record[] re;

	//
	// Create an empty table big enough to hold maxSize records.
	//
	public StringTable(int maxSize) 
	{
		//		int p = 1;
		//		int val = 0;
		//		while(val < maxSize) {
		//			val = (int) Math.pow(2, p);
		//			p++;
		//		}
		//		re = new Record[val];
		//		m = maxSize;
		//		for(int j = 0; j < val; j++) {
		//			re[j] = null;
		//		}
		re = new Record[2];
		for(int j = 0; j<2; j++){
			re[j] = null;
		}

	}

//Doubles the size of table and inserts values from old table into new table by rehashing them due to the dependence of the hashkey
//on the length of the table.
	public void resize(){
		Record[] t = re; 
		re = new Record [2 * t.length];
		rec = 0;
		m = 2 * m;
		for(int j = 0; j< t.length; j++){
			if((t[j] != null) && (t[j].keyInt() != -1)){
				insert(t[j]);
			}

		}	
	}


	// Insert a Record r into the table.  Return true if
	// successful, false if the table is full.
	public boolean insert(Record r) 
	{ 
		double lf = (1.0 * rec +1)/re.length; 
		if(lf > .25){
			resize();
		}

		if(find(r.getKey()) != null){
			return false;
		}

		if(r.keyInt()== -1 ){
			return false;
		}
		int hash = hash(r.getKey());
		re[hash] = r;
		rec++;

		return true; 
	}


	//
	// Delete a Record r from the table.
	//
	public void remove(Record r) 
	{
		int c = hash(r.getKey());
		if(re[c] == null || re[c].keyInt() == -1){}
		else{
			re[c] = new Record("clowntown");
			re[c].setKeyInt(-1);
		}
	}


	//
	// Find a record with a key matching the input.  Return the
	// record if it exists, or null if no matching record is found.
	//
	public Record find(String key) 
	{
		int a = hash(key);
		int count = 0;
		if(re[a] == null || re[a].keyInt() == -1){
			return null;
		}
		else{
			if(count == re.length){
				return null;
			}
			return re[a];
		}
	}
//Implementation of hashing functions designed to keep above methods form getting too messy.
//Allows easy debugging and testing.
	public int hash(String key) {
		int hash = toHashKey(key);
		int h = baseHash(hash);
		int step = stepHash(hash);

		while((re[h] != null)){

			if(re[h] != null && re[h].keyInt()==hash){
				if(re[h].getKey().equals(key)){
					return h;
				}

			}	
			h = (h+step)%re.length;
		}
		return h;

	}


	///////////////////////////////////////////////////////////////////////


	// Convert a String key into an integer that serves as input to hash
	// functions.  This mapping is based on the idea of a linear-congruential
	// pesudorandom number generator, in which successive values r_i are 
	// generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment thrown in
	// so that we don't just compute successive powers of A mod M.
	//
	// We modify the above generator by perturbing each r_i, adding in
	// the ith character of the string and its offset, to alter the
	// pseudorandom sequence.
	//
	public static int toHashKey(String s)
	{
		int A = 1952786893;
		int B = 367257;
		int v = B;

		for (int j = 0; j < s.length(); j++)
		{
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) v = -v;
		return v;
	}
//Function H1
	int baseHash(int hashKey)
	{

		// Fill in your own hash function here
		double A = (Math.sqrt(5)-1.0)/2.0;
		int h = (int) (((hashKey * A % 1)) * re.length); 
		return h;

	}
//Function H2
	int stepHash(int hashKey)
	{
		// Fill in your own hash function here
		double A = (Math.sqrt(5)-1.0)/2.0;
		int step = (int) (((hashKey * A % 1))* re.length); 
		if(step%2 == 0){
			return step+1;
		}
		return step;
	}
}
